# (PART) R {-}

# Lo básico de R {#r-basics}

```{r, echo=FALSE}
img_path <- "R/img"
```

En este libro, utilizaremos el ambiente de software R para todo nuestro análisis. Aprenderá R y técnicas de análisis de datos simultáneamente. Por tanto, para continuar necesitará acceso a R. También recomendamos el uso de un _Integrated Development Environment_ (IDE), como RStudio, para guardar su trabajo. Recuerde que es común que un curso o taller ofrezca acceso a un ambiente de R y un IDE a través de su navegador de Web, como lo hace RStudio cloud^[https://rstudio.cloud]. Si tiene acceso a dicho recurso, no necesita instalar R y RStudio. Sin embargo, si tiene la intención de convertirse en analista experta de datos, recomendamos instalar estas herramientas en su computadora^[https://rafalab.github.io/dsbook/installing-r-rstudio.html].
Tanto R como RStudio son gratuitos y están disponibles en línea.

## Caso de estudio: los asesinatos con armas en EE. UU.

Imagínese que vive en Europa y se le ofrece un trabajo en una empresa estadounidense con muchas ubicaciones por todo EE. UU.. Es un gran trabajo, pero noticias con titulares como **Tasa de homicidios con armas de fuego de EE. UU. más alta que en otros países desarrollados**^[http://abcnews.go.com/blogs/headlines/2012/12/us-gun-ownership -homicide-rate-superior-que-otros-países-desarrollados/] ¿se preocupa? Gráficos como el siguiente pueden preocuparle aún más:


```{r murder-rate-example-1, echo=FALSE, warning=FALSE, message=FALSE, out.width="70%"}
##from http://abcnews.go.com/images/International/homocides_g8_countries_640x360_wmain.jpg
##knitr::include_graphics(file.path(img_path,"homocides_g8_countries_640x360_wmain.jpg"))
library(tidyverse)
library(ggplot2)
library(ggflags)
library(countrycode)

dat <- tibble(country = toupper(c("US", "Italy", "Canada", "UK", "Japan", "Germany", "France", "Russia")),
count = c(3.2, 0.71, 0.5, 0.1, 0, 0.2, 0.1, 0),
label = c(as.character(c(3.2, 0.71, 0.5, 0.1, 0, 0.2, 0.1)), "No Data"),
code = c("us", "it", "ca", "gb", "jp", "de", "fr", "ru"))


dat %>%
mutate(country = reorder(country, -count)) %>%
ggplot(aes(country, count, label = label)) +
geom_bar(stat = "identity", fill = "darkred") +
geom_text(nudge_y = 0.2, color = "darkred", size = 5) +
geom_flag(y = -.5, aes(country = code), size = 12) +
scale_y_continuous(breaks = c(0, 1, 2, 3, 4), limits = c(0,4)) +
geom_text(aes(6.25, 3.8, label="Source UNODC Homicide Statistics")) +
ggtitle(toupper("Homicide Per 100,000 in G-8 Countries")) +
xlab("") +
ylab("# of gun-related homicides\nper 100,000 people") +
ggthemes::theme_economist() +
theme(axis.text.x = element_text(size = 8, vjust = -12),
axis.ticks.x=element_blank(),
axis.line.x = element_blank(),
plot.margin = unit(c(1,1,1,1), "cm"))
```

<!--(Source:
[Ma&#39;ayan Rosenzweigh/ ABC News] (https://abcnews.go.com/blogs/headlines/2012/12/us-gun-ownership-homicide-rate-higher-than-other-developed-countries/), Datos de las estadísticas de homicidios de la UNODC) ->


O peor aún, esta versión de [everytown.org] (https://everytownresearch.org):
```{r murder-rate-example-2, echo=FALSE, out.width="70%"}
# from https://everytownresearch.org/wp-content/uploads/2016/07/GunTrends_murders_per_1000.png
# knitr::include_graphics(file.path(img_path,"GunTrends_murders_per_1000.png"))

dat <- tibble(country = toupper(c("United States", "Canada", "Portugal", "Ireland", "Italy", "Belgium", "Finland", "France", "Netherlands", "Denmark", "Sweden", "Slovakia", "Austria", "New Zealand", "Australia", "Spain", "Czech Republic", "Hungary", "Germany", "United Kingdom", "Norway", "Japan", "Republic of Korea")),
count = c(3.61, 0.5, 0.48, 0.35, 0.35, 0.33, 0.26, 0.20, 0.20, 0.20, 0.19, 0.19, 0.18, 0.16, 0.16, 0.15, 0.12, 0.10, 0.06, 0.04, 0.04, 0.01, 0.01))

dat %>%
mutate(country = reorder(country, count)) %>%
ggplot(aes(country, count, label = count)) +
geom_bar(stat = "identity", fill = "darkred", width = 0.5) +
geom_text(nudge_y = 0.2, size = 3) +
xlab("") + ylab("") +
ggtitle(toupper("Gun Homicides per 100,000 residents")) +
theme_minimal() +
theme(panel.grid.major =element_blank(), panel.grid.minor = element_blank(),
axis.text.x = element_blank(),
axis.ticks.length = unit(-0.4, "cm")) +
coord_flip()
```

<!--(Source [everytown.org](https://everytownresearch.org))-->

Pero entonces se recuerda que Estados Unidos es un país grande y diverso con 50 estados muy diferentes, además del Distrito de Columbia (DC).

```{r us-murders-by-state-map, message=FALSE, echo=FALSE}
library(tidyverse)
library(dslabs)

fifty_states <- map_data("state")
data(murders)
murders %>% mutate(murder_rate = total/population*10^5,
state = tolower(state),
colors= factor(ceiling(pmin(murder_rate, 9)))) %>%
ggplot(aes(map_id = state)) +
geom_map(aes(fill = colors), color = "black", map = fifty_states) +
expand_limits(x = fifty_states$long, y = fifty_states$lat) +
coord_map() +
scale_x_continuous(breaks = NULL) +
scale_y_continuous(breaks = NULL) +
labs(x = "", y = "") +
theme(panel.background = element_blank()) +
scale_fill_brewer(guide=FALSE) +
theme_minimal()
rm(fifty_states)
```


California, por ejemplo, tiene una población más grande que Canadá, y 20 estados de EE.UU. tienen poblaciones más grandes que la de Noruega. En algunos aspectos, la variabilidad entre los estados de EE.UU. es parecida a la variabilidad entre los países de Europa. Además, aunque no se incluyen en los cuadros anteriores, las tasas de asesinatos en Lituania, Ucrania y Rusia son superiores a cuatro por cada 100.000. Entonces, es posible que las noticias que le preocupan sean demasiado superficial. Tiene opciones de dónde puede vivir y desea determinar la seguridad de cada estado en particular. Obtendremos algunas ideas al examinar los datos relacionados con homicidios con armas de fuego de EE.UU. en 2010 usando R.

Antes de comenzar con nuestro ejemplo, necesitamos discutir la logística, así como algunos de los componentes básicos necesarios para obtener destrezas de R más avanzadas. Recuerde que la utilidad de algunos de estos bloques de construcción no siempre es obvia inmediatamente, pero luego en el libro apreciará haber dominado estas destrezas.

## Lo básico

Antes de comenzar con el [FIX:] motivating dataset/motivador conjunto de datos, necesitamos repasar los conceptos básicos de R.

### Objetos

Supongamos que unos estudiantes de secundaria nos piden ayuda para resolver varias ecuaciones cuadráticas de la forma $ax^2+bx+c = 0$. La fórmula cuadrática nos ofrece las soluciones:

$$
\frac{-b - \sqrt{b^2 - 4ac}}{2a}\,\, \mbox{ and } \frac{-b + \sqrt{b^2 - 4ac}}{2a}
$$
que por supuesto cambian dependiendo de los valores de $a$, $b$ y $c$. Una ventaja de los lenguajes de programación es poder definir variables y escribir expresiones con estas, como se hace en las matemáticas, para obtener una solución numérica. Escribiremos un código general para la ecuación cuadrática a continuación, pero si nos piden resolver $x^2 + x -1 = 0$, entonces definimos:

```{r}
a <- 1
b <- 1
c <- -1
```

que almacena los valores para su uso posterior. Usamos `<-` para asignar valores a las variables.

También podemos asignar valores usando `=` en lugar de `<-`, pero recomendamos no usar `=` para evitar confusión.

Copie y pegue el código anterior en su consola para definir las tres variables. Tenga en cuenta que R no imprime nada cuando hacemos esta asignación. Esto significa que los objetos se definieron con éxito. Si hubiera cometido un error, habría aparecido un mensaje de error.

Para ver el valor almacenado en una variable, simplemente le pedimos a R que evalúe `a` y este muestra el valor almacenado:

```{r}
a
```

Una forma más explícita de pedirle a R que nos muestre el valor almacenado en `a` es usar `print` así:

```{r}
print(a)
```

Usamos el término "objeto" para describir cosas que están almacenadas en R. Las variables son ejemplos, pero los objetos también pueden ser entidades más complicadas como funciones, que se describen más adelante.



### El espacio de trabajo

A medida que definimos objetos en la consola, estamos cambiando el espacio de trabajo. Puede ver todas las variables guardadas en su espacio de trabajo al escribir:

```{r}
ls()
```

En RStudio, la pestaña _Environment_ muestra los valores:

```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path,"rstudio-environment.png"))
```

Deberíamos ver `a`, `b` y `c`. Si intenta recuperar el valor de una variable que no está en su espacio de trabajo, recibirá un mensaje de error. Por ejemplo, si escribe `x`, verá lo siguiente: `Error: object 'x' not found`.

Ahora, dado que estos valores se guardan en variables, para resolver nuestra ecuación, utilizamos la fórmula cuadrática:

```{r}
(-b + sqrt(b^2 - 4*a*c) )/ ( 2*a )
(-b - sqrt(b^2 - 4*a*c) )/ ( 2*a )
```


### Funciones

Una vez que defina las variables, el proceso de análisis de datos generalmente se puede describir como una serie de funciones aplicadas a los datos. R incluye varias funciones predefinidas y la mayoría de las líneas de análisis que construimos hacen uso extensivo de ellas.

Ya usamos las funciones `install.packages`, `library` y `ls`. También usamos la función `sqrt` para solucionar la ecuación cuadrática anterior. Hay muchas más funciones [FIX:] preconstruidas/predeterminadas (prebuilt) y hasta más se pueden añadir a través de paquetes. Estas no aparecen en el espacio de trabajo porque no las definió, pero están disponibles para su uso inmediato.

En general, necesitamos usar paréntesis para evaluar una función. Si escribe `ls`, la función no se evalúa y en cambio R le muestra el código que la define. Si escribe `ls()`, la función se evalúa y, como ya se mostró, vemos objetos en el espacio de trabajo.

A diferencia de `ls`, la mayoría de las funciones requieren uno o más argumentos. A continuación se muestra un ejemplo de cómo asignamos un objeto al argumento de la función `log`. Recuerda que anteriormente definimos `a` como 1:

```{r}
log(8)
log(a)
```

Puede averiguar lo que la función espera y lo que hace revisando unos manuales muy útiles incluidos en R. Puede obtener ayuda utilizando la función `help` así:

```{r, eval=FALSE}
help("log")
```

Para la mayoría de las funciones, también podemos usar esta abreviatura:

```{r, eval=FALSE}
?log
```

La página de ayuda le mostrará qué argumentos espera la función. Por ejemplo, `log` necesita `x` y `base` para correr. Sin embargo, algunos argumentos son obligatorios y otros son opcionales. Puede determinar cuáles son opcionales observando en el documento de ayuda que `=` asigna un valor predeterminado. Definir esto es opcional. Por ejemplo, la base de la función `log` por defecto es `base = exp(1)` haciendo `log` el registro natural por defecto.

Para echar un vistazo rápido a los argumentos sin abrir el sistema de ayuda, puede escribir:

```{r}
args(log)
```

Puede cambiar los valores predeterminados simplemente asignando otro objeto:

```{r}
log(8, base = 2)
```

Recuerde que no hemos estado especificando el argumento `x` como tal:
```{r}
log(x = 8, base = 2)
```

El código anterior funciona, pero también podemos ahorrarnos un poco de tecleo: si no usa un nombre de argumento, R supone que está ingresando argumentos en el orden en que se muestran en el archivo de ayuda o por `args`. Entonces, al no usar los nombres, R supone que los argumentos son `x` seguido por `base`:

```{r}
log(8,2)
```

Si usa los nombres de los argumentos, podemos incluirlos en el orden en que queramos:

```{r}
log(base = 2, x = 8)
```

Para especificar argumentos, debemos usar `=` y no `<-`.

Hay algunas excepciones a la regla de que las funciones necesitan los paréntesis para ser evaluadas. Entre estas, los más utilizados son los símbolos de operaciones aritméticas y de relación. Por ejemplo:

```{r}
2^3
```

Puede ver los símbolos de operaciones aritméticas al escribir:

```{r, eval = TRUE}
help("+")
```

o

```{r, eval = TRUE}
?"+"
```

y los símbolos de relación escribiendo:

```{r, eval = TRUE}
help(">")
```

o

```{r}
?">"
```

### [FIX:] Otros objetos preconstruidos/predeterminados

Hay varios conjuntos de datos que se incluyen para que los usuarios practiquen y prueben funciones. Puede ver todos los conjuntos de datos disponibles escribiendo:

```{r}
data()
```

Esto le muestra el nombre del objeto para estos conjuntos de datos. Estos conjuntos de datos son objetos que se pueden usar simplemente escribiendo el nombre. Por ejemplo, si escribe:

```{r, eval=FALSE}
co2
```
R le mostrará los datos de concentración de CO2 atmosférico de Mauna Loa.

Otros objetos preconstruidos son cantidades matemáticas, como la constante $\pi$ y $\infty$:

```{r}
pi
Inf+1
```

### Nombres de variables

Hemos usado las letras `a`, `b` y `c` como nombres de variables, pero estos pueden ser casi cualquier cosa. Algunas reglas básicas en R son que los nombres de variables tienen que comenzar con una letra, no pueden contener espacios y no deben ser variables predefinidas en R. Por ejemplo, no nombre una de sus variables `install.packages` escribiendo algo como:
`install.packages <- 2`.

Una buena convención a seguir es usar palabras significativas que describan lo que está almacenado, usar solo minúsculas y usar guiones bajos como sustituto de espacios. Para las ecuaciones cuadráticas, podríamos usar algo como:

```{r}
solution_1 <- (-b + sqrt(b^2 - 4*a*c))/ (2*a)
solution_2 <- (-b - sqrt(b^2 - 4*a*c))/ (2*a)
```

Para obtener más consejos, recomendamos estudiar la guía de estilo de Hadley Wickham^[http://adv-r.had.co.nz/Style.html].

### Guardar su espacio de trabajo

Los valores permanecen en el espacio de trabajo hasta que finalice su sesión o los borre con la función `rm`. Pero los espacios de trabajo también se pueden guardar para su uso posterior. De hecho, al salir de R, el programa le pregunta si desea guardar su espacio de trabajo. Si lo guarda, la próxima vez que inicie R, el programa restaurará el espacio de trabajo.

En realidad, recomendamos no guardar el espacio de trabajo así porque, a medida que comience a trabajar en diferentes proyectos, será más difícil darle seguimiento de lo que se guarda. En cambio, le recomendamos que asigne al espacio de trabajo un nombre específico. Puede hacer esto usando las funciones `save` o `save.image`. Para cargar, use la función `load`. Al guardar un espacio de trabajo, recomendamos el sufijo `rda` o `RData`. En RStudio, también puede hacerlo navegando a la pestaña _Session_ y eligiendo _Save Workspace as_. Luego puede cargarlo usando las opciones _Load Workspace_ en la misma pestaña. Si quiere aprender más, lea las páginas de ayuda en `save`, `save.image` y `load`.


### [FIX:] _Scripts_ motivadores/motivating

Para resolver otra ecuación como $3x^2 + 2x -1$, podemos copiar y pegar el código anterior, redefinir las variables y volver a calcular la solución:

```{r, eval=FALSE}
a <- 3
b <- 2
c <- -1
(-b + sqrt(b^2 - 4*a*c))/ (2*a)
(-b - sqrt(b^2 - 4*a*c))/ (2*a)
```

Al crear y guardar un _script_ con el código anterior, ya no tendrá que volver a escribirlo todo cada vez, sino simplemente cambiar los nombres de las variables. Intente escribir la secuencia de comandos anteriores en un editor y observe lo fácil que es cambiar las variables y recibir una respuesta.

### Comentando tu código

Si una línea de código R comienza con el símbolo `#`, no se evalúa. Podemos usar esto para escribir recordatorios de por qué escribimos un código particular. Por ejemplo, en el _script_ anterior, podríamos agregar:


```{r, eval=FALSE}
## Código para calcular la solución a la ecuación cuadrática de la forma ax^2 + bx + c
## definir las variables
a <- 3
b <- 2
c <- -1

## ahora calcule la solución
(-b + sqrt(b^2 - 4*a*c))/ (2*a)
(-b - sqrt(b^2 - 4*a*c))/ (2*a)
```


## Ejercicios

1\. ¿Cuál es la suma de los primeros 100 números enteros positivos? La fórmula para la suma de enteros $1$ a $n$ es $n(n+1)/2$. Define $n=100$ y luego usa R para calcular la suma de $1$ a $100$ usando la fórmula ¿Cuál es la suma?

2\. Ahora use la misma fórmula para calcular la suma de los enteros del 1 a 1000.

3\. Mire el resultado de escribir el siguiente código en R:

```{r, eval=FALSE}
n <- 1000
x <- seq(1, n)
sum(x)
```

Basado en el resultado, ¿qué cree que hacen las funciones `seq` y `sum`? Puede usar `help`.

a. `sum` crea una lista de números y `seq` los suma.
b. `seq` crea una lista de números y `sum` los suma.
c. `seq` crea una lista aleatoria y `sum` calcula la suma de 1 a 1000.
d. `sum` siempre devuelve el mismo número.

4\. En las matemáticas y la programación, decimos que evaluamos una función cuando reemplazamos el argumento con un número dado. Entonces si escribimos `sqrt(4)`, evaluamos la función `sqrt`. En R, se puede evaluar una función dentro de otra función. Las evaluaciones suceden de adentro hacia afuera. Use una línea de código para calcular el registro, en base 10, de la raíz cuadrada de 100.


5\. ¿Cuál de los siguientes siempre devolverá el valor numérico almacenado en `x`? Puede probar ejemplos y usar el sistema de ayuda si lo desea.

a. `log(10^x)`
b. `log10(x^10)`
c. `log(exp(x))`
d. `exp(log(x, base = 2))`


## [FIX:] Tipos de datos/ Data types

Las variables en R pueden ser de diferentes tipos. Por ejemplo, necesitamos distinguir números de cadenas de caracteres y tablas de listas sencillas de números. La función `class` nos ayuda a determinar qué tipo de objeto tenemos:

```{r}
a <- 2
class(a)
```

Para trabajar eficientemente en R, es importante aprender los diferentes tipos de variables y qué podemos hacer con ellas.

### _Data frames_

Hasta ahora, las variables que hemos definido son solo un número. Esto no es muy útil para almacenar datos. La forma más común de almacenar un conjunto de datos en R es usando un _data frame_. Conceptualmente, podemos pensar en un _data frame_ como una tabla con filas que representan observaciones y con columnas que representan las diferentes variables recopiladas para cada observación. Los _data frames_ son particularmente útiles para conjuntos de datos porque podemos combinar diferentes tipos de datos en un solo objeto.

Una gran proporción de los retos del análisis de datos comienza con datos almacenados en un _data frame_. Por ejemplo, almacenamos los datos para nuestro ejemplo [FIX:]  motivador en un _data frame_. Puede tener acceso a este conjunto de datos cargando la biblioteca __dslabs__ y el conjunto de datos `murders` utilizando la función `data`:

```{r}
library(dslabs)
data(murders)
```

Para verificar que esto es un _data frame_, escribimos:

```{r}
class(murders)
```

### Examinando un objeto

La función `str` es útil para obtener más información sobre la estructura de un objeto:

```{r, echo=FALSE}
# change str to make sure it stays within margins
str <- function(x) utils::str(x, strict.width = 'wrap')
```

```{r}
str(murders)
```

```{r, echo=FALSE}
# remove str we defiend
rm(str)
```

Esto nos dice mucho más sobre el objeto. Vemos que la tabla tiene 51 filas (50 estados más DC) y cinco variables. Podemos mostrar las primeras seis líneas usando la función `head`:

```{r}
head(murders)
```

En este conjunto de datos, cada estado se considera una observación y se incluyen cinco variables para cada estado.

Antes de continuar con la respuesta a nuestra pregunta original sobre los diferentes estados, repasemos más sobre los componentes de este objeto.

### [FIX:] The accessor: `$`

Para nuestro análisis, necesitaremos acceso a las diferentes variables representadas por columnas incluidas en este _data frame_. Para hacer esto, utilizamos [FIX:] the access operator/el operador de acceso `$` de la siguiente manera:

```{r}
murders$population
```

¿Pero cómo supimos usar `population`? Anteriormente, aplicando la función `str` al objeto `murders`, revelamos los nombres de cada una de las cinco variables almacenadas en esta tabla. Podemos tener acceso rápido a los nombres de las variables usando:

```{r}
names(murders)
```

Es importante saber que el orden de las entradas en `murders$population` conserva el orden de las filas en nuestra tabla de datos. Esto luego nos permitirá manipular una variable basada en los resultados de otra. Por ejemplo, podremos ordenar los nombres de los estados según el número de asesinatos.

**Consejo**: R viene con una muy buena funcionalidad de autocompletar que nos ahorra la molestia de escribir todos los nombres. [FIX:] Intente escribir `murders$p` luego presionando la tecla _tab_ en su teclado. Esta funcionalidad y muchas otras funciones útiles de autocompletar están disponibles cuando se trabaja en RStudio.

### Vectores: numéricos, caracteres y lógicos

El objeto `murders$population` no es un número sino varios. Llamamos _vectores_ a este tipo de objeto. Un solo número es técnicamente un vector de longitud 1, pero en general usamos el término vectores para referirnos a objetos con varias entradas. La función `length` le dice cuántas entradas hay en el vector:

```{r}
pop <- murders$population
length(pop)
```

Este vector particular es numérico ya que los tamaños de la población son números:

```{r}
class(pop)
```
En un vector numérico, cada entrada debe ser un número.

Para almacenar una secuencia de caracteres, los vectores también pueden ser de la clase caracter. Por ejemplo, los nombres de los estados son caracteres:

```{r}
class(murders$state)
```

Al igual que con los vectores numéricos, todas las entradas en un vector de caracteres deben ser un carácter.

Otro tipo importante de vectores son los vectores lógicos. Estos deben ser `TRUE` o `FALSE`.

```{r}
z <- 3 == 2
z
class(z)
```

Aquí el `==` es un símbolo de relación que pregunta si 3 es igual a 2. En R, usar solo un `=` asigna una variable, pero si usa dos `==` entonces coteja si los objetos son iguales.

Puede ver cescribiendo:

```{r, eval=FALSE}
?Comparison
```

En futuras secciones, observará lo útil que pueden ser los símbolos de relación.

Discutimos características más importantes de los vectores después de los siguientes ejercicios.


**Avanzado**: Matemáticamente, los valores en `pop` son números enteros y hay una clase de enteros en R. Sin embargo, por defecto, a los números se les asigna una clase numérica incluso cuando son enteros redondos. Por ejemplo, `class(1)` devuelve numérico. Puede convertirlo en un entero de clase con la función `as.integer()` o agregando un `L` así: `1L`. Tenga en cuenta la clase escribiendo: `class(1L)`


### Factores {#factors}

En el conjunto de datos `murders`, se podría esperar que la región también sea un vector de caracteres. Sin embargo, no lo es:

```{r}
class(murders$region)
```

Es un factor. Los factores son útiles para almacenar datos categóricos. Podemos ver que solo hay cuatro regiones al utilizar la función `levels`:


```{r}
levels(murders$region)
```

En el fondo, R almacena estos _levels_ como números enteros y mantiene un mapa para llevar un registro de las etiquetas. Esto es más eficiente en terminos de memoria que almacenar todos los caracteres.

Recuerden que los _levels_ tienen un orden que es diferente del orden de aparición en el objeto factor. El valor por defecto de los _levels_ es seguir el orden alfabético. Sin embargo, a veces queremos que los _levels_ sigan un orden diferente. Tendremos varios ejemplos de esto en la parte de visualización de datos del libro. La función `reorder` nos permite cambiar el orden de los _levels_ de un factor variable según un resumen calculado en un vector numérico. Demostremos esto con un ejemplo sencillo.

Supongamos que queremos los _levels_ de la región por el número total de asesinatos en vez de por orden alfabético. Si hay valores asociados con cada _level_, podemos usar el `reorder` y especificar un resumen de datos para determinar el orden. El siguiente código toma la suma del total de asesinatos en cada región y reordena el factor siguiendo esta.

```{r}
region <- murders$region
value <- murders$total
region <- reorder(region, value, FUN = sum)
levels(region)
```

El nuevo orden concuerda con el hecho de que hay menos asesinatos en el noreste y más en el sur.

**Advertencia**: los factores pueden ser una fuente de confusión ya que a veces se comportan como caracteres y otras veces no. Como resultado, estos son una fuente común de errores.

### Listas

_Data frames_ son un caso especial de _listas_. Cubriremos las listas con más detalle más adelante, pero sabemos que son útiles porque pueden almacenar cualquier combinación [FIX:] de diferentes tipos. Aquí creamos una lista para servir de ejemplo :


```{r, echo=FALSE}
record <- list(name = "John Doe",
student_id = 1234,
grades = c(95, 82, 91, 97, 93),
final_grade = "A")
```

```{r}
record
class(record)
```

Al igual que con los _data frames_, puede extraer los componentes de una lista con [FIX:] el _accesor_ `$`. De hecho, los _data frames_ son un tipo de lista.

```{r}
record$student_id
```

También podemos usar corchetes dobles ( `[[`) así:

```{r}
record[["student_id"]]
```

Debe acostumbrarse al hecho de que en R a menudo hay varias formas de hacer lo mismo, como tener acceso a las entradas.

También puede encontrar listas sin nombres de variables.

```{r, echo=FALSE}
record2 <- list("John Doe",
1234)
```

```{r}
record2
```

Si una lista no tiene nombres, no puede extraer los elementos con `$`, pero puede usar el método de corchetes. [FIX:] En vez de proporcionar el nombre de la variable, puede proporcionar el índice de la lista de la siguiente manera:

```{r}
record2[[1]]
```


No usaremos listas hasta más tarde, pero es posible que encuentre una en su propia exploración de R. Por eso, le mostramos algunos conceptos básicos aquí.


###  Matrices {#matrices}

Las matrices son otro tipo de objeto común en R. Las matrices son similares a los _data frames_ en que son bidimensionales: tienen filas y columnas. Sin embargo, al igual que los vectores numéricos, de caracteres y lógicos, las entradas en las matrices deben ser del mismo tipo. Por esta razón, los _data frames_ son mucho más útiles para almacenar datos, ya que podemos tener caracteres, factores y números en ellos.

Sin embargo, las matrices tienen una gran ventaja sobre los _data frames_: podemos realizar operaciones de álgebra matricial, un poderoso tipo de técnica matemática. No describimos estas operaciones en este libro, pero gran parte de lo que sucede en segundo plano cuando realiza un análisis de datos involucra matrices. Cubrimos las matrices con más detalle en el Capítulo \@ref(matrix-algebra) pero también las discutimos brevemente aquí, ya que algunas de las funciones que aprenderemos devuelven matrices.

Podemos definir una matriz usando la función `matrix`. Necesitamos especificar el número de filas y columnas.

```{r}
mat <- matrix(1:12, 4, 3)
mat
```

Puede acceder a entradas específicas en una matriz usando corchetes ( `[`). Si desea la segunda fila, tercera columna, usa:

```{r}
mat[2, 3]
```

Si desea toda la segunda fila, deje vacío el lugar de la columna:

```{r}
mat[2, ]
```

Tenga en cuenta que esto devuelve un vector, no una matriz.

Del mismo modo, si desea la tercera columna completa, deje el lugar de la fila vacío:

```{r}
mat[, 3]
```

Esto también es un vector, no una matriz.

Puede acceder a más de una columna o más de una fila si lo desea. Esto le dará una nueva matriz.

```{r}
mat[, 2:3]
```

Puede [FIX:] subset tanto filas como columnas:

```{r}
mat[1:2, 2:3]
```

Podemos convertir matrices en _data frames_ usando la función `as.data.frame`:

```{r}
as.data.frame(mat)
```

También puede usar corchetes individuales ( `[`) para acceder a las filas y las columnas de un _data frame_:

```{r}
data("murders")
murders[25, 1]
murders[2:3, ]
```


## Ejercicios

1\. Cargue el conjunto de datos de asesinatos de EE. UU..

```{r}
library(dslabs)
data(murders)
```

Use la función `str` para examinar la estructura del objeto `murders`. ¿Cuál de las siguientes opciones describe mejor las variables representadas en este _data frame_?

a. Los 51 estados.
b. Las tasas de asesinatos para los 50 estados y DC.
c. El nombre del estado, la abreviatura del nombre del estado, la región del estado y la población y el número total de asesinatos para 2010 del estado.
d. `str` no muestra información relevante.

2\. ¿Cuáles son los nombres de columna utilizados por el _data frame_ para estas cinco variables?

3\. Use el _accesor_ `$` para extraer las abreviaturas de estado y asignarlas al objeto `a`. ¿Cuál es la clase de este objeto?

4\. Ahora use los corchetes para extraer las abreviaturas de estado y asignarlas al objeto `b`. Utilice la función `identical` para determinar si `a` y `b` son iguales.

5\. Vimos que la columna `region` almacena un factor. Puede corroborar esto escribiendo:

```{r, eval=FALSE}
class(murders$region)
```

Con una línea de código, use las funciones `levels` y `length` para determinar el número de regiones definidas por este conjunto de datos.

6\. La función `table` toma un vector y devuelve la frecuencia de cada elemento. Puede ver rápidamente cuántos estados hay en cada región aplicando esta función. Use esta función en una línea de código para crear una tabla de estados por región.

## Vectores

En R, los objetos más básicos disponibles para almacenar datos son _vectores_. Como hemos visto, los conjuntos de datos complejos generalmente se pueden dividir en componentes que son vectores. Por ejemplo, en un _data frame_, cada columna es un vector. Aquí aprendemos más sobre esta importante clase.

### Crear vectores

Podemos crear vectores usando la función `c`, que significa _concatenate_. Usamos `c` para concatenar entradas de la siguiente manera:

```{r}
codes <- c(380, 124, 818)
codes
```

También podemos crear vectores de caracteres. Usamos las comillas para denotar que las entradas son caracteres en lugar de nombres de variables.

```{r}
country <- c("italy", "canada", "egypt")
```

En R también puedes usar comillas sencillas:

```{r}
country <- c('italy', 'canada', 'egypt')
```

[FIX:] Pero tenga cuidado de no confundir la comilla sencilla ' con el _back quote_ `.  

A estas alturas ya debería saber que si escribe:

```{r, eval=FALSE}
country <- c(italy, canada, egypt)
```
recibe un error porque las variables `italy`, `canada` y `egypt` no están definidas. Si no usamos las comillas, R busca variables con esos nombres y devuelve un error.

### Nombres

A veces es útil nombrar las entradas de un vector. Por ejemplo, al definir un vector de códigos de país, podemos usar los nombres para conectar los dos:

```{r}
codes <- c(italy = 380, canada = 124, egypt = 818)
codes
```

El objeto `codes` sigue siendo un vector numérico:
```{r}
class(codes)
```
pero con nombres:
```{r}
names(codes)
```

Si el uso de [FIX:] cadenas sin comillas parece confuso, sepa que también puede usar las comillas:

```{r}
codes <- c("italy" = 380, "canada" = 124, "egypt" = 818)
codes
```

No hay diferencia entre esta [FIX:] llamada a función (function call) y la anterior. Esta es una de las muchas formas en que R es peculiar en comparación con otros lenguajes.

También podemos asignar nombres usando la función `names`:

```{r}
codes <- c(380, 124, 818)
country <- c("italy","canada","egypt")
names(codes) <- country
codes
```

### Secuencias

Otra función útil para crear vectores genera secuencias:

```{r}
seq(1, 10)
```

El primer argumento define el inicio y el segundo define el final que incluimos. El valor por defecto es subir en incrementos de 1, pero un tercer argumento nos permite decir cuánto saltar:

```{r}
seq(1, 10, 2)
```

Si queremos enteros consecutivos, podemos usar la siguiente taquigrafía:

```{r}
1:10
```

Cuando usamos estas funciones, R produce números enteros, no numéricos, porque generalmente se usan [FIX:] to index something/para poner algo en un índice:

```{r}
class(1:10)
```

Sin embargo, si creamos una secuencia que incluye no enteros, la clase cambia:

```{r}
class(seq(1, 10, 0.5))
```

### [FIX:] _Subsetting_/Creando un subconjunto

Usamos corchetes para tener acceso a elementos específicos de un vector. Para el vector `codes` que definimos anteriormente, podemos tener acceso al segundo elemento usando:
```{r}
codes[2]
```

Puede obtener más de una entrada utilizando un vector de entradas múltiples como índice:
```{r}
codes[c(1,3)]
```

Las secuencias definidas anteriormente son particularmente útiles si necesitamos acceso, digamos, a los dos primeros elementos:

```{r}
codes[1:2]
```

Si los elementos tienen nombres, también podemos acceder a las entradas utilizando estos nombres. A continuación ofrecemos dos ejemplos:

```{r}
codes["canada"]
codes[c("egypt","italy")]
```

## Coerción

En general, la _coerción_ es un intento de R de ser flexible con los tipos de datos. Cuando una entrada no coincide con lo esperado, algunas de las funciones preconstruidas de R tratan de adivinar lo que uno intentaba antes de devolver un mensaje de error. Esto también puede causar confusión. Al no entender la coerción, los programadores pueden volverse locos cuando codifican en R, ya que R se comporta de manera bastante diferente a la mayoría de los otros idiomas en cuanto a esto. Aprendamos más con unos ejemplos.

Dijimos que los vectores deben ser todos del mismo tipo. Entonces, si tratamos de combinar, por ejemplo, números y caracteres, puede esperar un error:

```{r}
x <- c(1, "canada", 3)
```

¡Pero no nos da uno, ni siquiera una advertencia! ¿Que pasó? Mire `x` y su clase:

```{r}
x
class(x)
```

[FIX:] R _coerce_/cambió los datos en caracteres. Como pusimos una cadena de caracteres en el vector, R adivinó que nuestra intención era que el 1 y el 3 fueran las cadenas de caracteres `"1"` y " `3`&Quot;. El hecho de que ni siquiera emitiera una advertencia es un ejemplo de cómo la coerción puede causar muchos errores inadvertidos en R.

R también ofrece funciones para cambiar de un tipo a otro. Por ejemplo, puede convertir números en caracteres con:

```{r}
x <- 1:5
y <- as.character(x)
y
```

Puede devolverlo con `as.numeric`:

```{r}
as.numeric(y)
```

Esta función es realmente bastante útil ya que los conjuntos de datos que incluyen números como cadenas de caracteres son comunes.

### No disponible (NA)

Cuando una función intenta [FIX:] coerce/coaccionar un tipo a otro y encuentra un caso imposible, generalmente nos da una advertencia y convierte la entrada en un valor especial llamado `NA` que significa "no disponible" ( _not available_ en inglés). Por ejemplo:

```{r}
x <- c("1", "b", "3")
as.numeric(x)
```

R no tiene ninguna conjetura sobre el número que desea cuando escribe `b`, por lo que no lo intenta.

Como científicos de datos, se encontrarán con el `NA` frecuentemente ya que se usa generalmente para datos que faltan, un problema común en los conjuntos de datos del mundo real.

## Ejercicios

1\. Use la función `c` para crear un vector con las temperaturas altas promedio en enero para Beijing, Lagos, París, Río de Janeiro, San Juan y Toronto, que son 35, 88, 42, 84, 81 y 30 grados Fahrenheit. Llame al objeto `temp`.

2\. Ahora cree un vector con los nombres de las ciudades y llame al objeto `city`.


3\. Utilice la función `names` y los objetos definidos en los ejercicios anteriores para asociar los datos de temperatura con su ciudad correspondiente.


4\. Utilice los _operators_ `[` y `:` para acceder a la temperatura de las tres primeras ciudades de la lista.


5\. Utilice el _operator_ `[` para acceder a la temperatura de París y San Juan.

6\. Utilice el _operator_ `:` para crear una secuencia de números $12,13,14,\dots,73$.

7\. Cree un vector que contenga todos los números impares positivos menores que 100.

8\. Cree un vector de números que comience en 6, no pase 55 y agregue números en incrementos de 4/7: 6, 6 + 4/7, 6 + 8/7, y así sucesivamente. ¿Cuántos números tiene la lista? Sugerencia: use `seq` y `length`.

9\. ¿Cuál es la clase del siguiente objeto? `a <- seq(1, 10, 0.5)`?


10\. ¿Cuál es la clase del siguiente objeto? `a <- seq(1, 10)`?


11\. La clase de `class(a<-1)` es numérico, no entero. R por defecto es numérico y para forzar un número entero, debe agregar la letra `L`. Confirme que la clase de `1L` es entero.


12\. Defina el siguiente vector:

```{r}
x <- c("1", "3", "5")
```

y oblíguelo a obtener enteros.




## _Sorting_

Ahora que hemos dominado algunos conocimientos básicos de R, intentemos obtener algunos conocimientos sobre la seguridad de los distintos estados en el contexto de los asesinatos con armas de fuego.

### `sort`

Digamos que queremos clasificar los estados desde el menor hasta el mayor según los asesinatos con armas de fuego. La función `sort` ordena un vector en orden creciente. Por lo tanto, podemos ver la mayor cantidad de asesinatos con armas escribiendo:

```{r}
library(dslabs)
data(murders)
sort(murders$total)
```

Sin embargo, esto no nos da información sobre qué estados tienen qué total de asesinatos. Por ejemplo, no sabemos qué estado tuvo `r max(murders$total)`.

### `order`

La función `order` está más cerca de lo que queremos. `order` toma [FIX:] un vector como entrada y devuelve el vector de índices que clasifica el vector de entrada. Esto puede confuso, así que estudiemos un ejemplo simple. Podemos crear un vector y ordenarlo:

```{r}
x <- c(31, 4, 15, 92, 65)
sort(x)
```

 [FIX:] En lugar de ordenar el vector de entrada, la función `order` devuelve el índice que [FIX:]ordena el vector de entrada:

```{r}
index <- order(x)
x[index]
```

Este es el mismo resultado que le devuelve `sort(x)`. Si miramos este índice, vemos por qué funciona:
```{r}
x
order(x)
```

La segunda entrada de `x` es la más pequeñA, entonces `order(x)` comienza con `2`. La siguiente más pequeña es la tercera entrada, por lo que la segunda entrada es `3` y así sigue.

¿Cómo nos ayuda esto a ordenar los estados por asesinatos? Primero, recuerde que las entradas de vectores a las que accede con `$` sigue el mismo orden que las filas de la tabla. Por ejemplo, estos dos vectores que contienen nombres de estado y abreviaturas, respectivamente, [FIX:]se corresponden por su orden/are matched by their order:

```{r}
murders$state[1:6]
murders$abb[1:6]
```

[FIX:] Esto significa que podemos poner los nombres de estado en orden según el total de asesinatos. Primero obtenemos el índice que pone los vectores en orden según el total de asesinatos y luego ponemos el vector de nombres de estado en un índice:

```{r}
ind <- order(murders$total)
murders$abb[ind]
```

De acuerdo con lo anterior, California tuvo la mayor cantidad de asesinatos.

### `max` y `which.max`

Si solo estamos interesados en la entrada con el mayor valor, podemos usar `max` para ese valor:

```{r}
max(murders$total)
```

y `which.max` para [FIX:] el índice de mayor valor:

```{r}
i_max <- which.max(murders$total)
murders$state[i_max]
```

Como mínimo, podemos usar `min` y `which.min` del mismo modo.

¿Esto significa que California es el estado más peligroso? En una próxima sección, planteamos que deberíamos considerar las tasas en lugar de los totales. Antes de hacer eso, presentamos una última función relacionada con el orden: `rank`.

### `rank`

Aunque no se usa con tanta frecuencia como `order` y `sort`, la función `rank` también está relacionada con el orden y puede ser útil.
Para cualquier [FIX:] vector dado/determinado, `rank` devuelve un vector con el rango de la primera entrada, segunda entrada, etc., del vector de entrada. Aquí tenemos un ejemplo simple:

```{r}
x <- c(31, 4, 15, 92, 65)
rank(x)
```

Para resumir, veamos los resultados de las tres funciones que hemos introducido:

```{r, echo=FALSE}
tmp <- data.frame(original=x, sort=sort(x), order=order(x), rank=rank(x))
if(knitr::is_html_output()){
knitr::kable(tmp, "html") %>%
kableExtra::kable_styling(bootstrap_options = "striped", full_width = FALSE)
} else{
knitr::kable(tmp, "latex", booktabs = TRUE) %>%
kableExtra::kable_styling(font_size = 8)
}
```


### Cuidado con el reciclaje

[FIX:] Otra fuente común de errores inadvertidos en R es el uso del reciclaje/recycling. Hemos visto como los vectores se agregan por elementos. Entonces, si los vectores no coinciden en longitud, es natural suponer que obtendramos un error. Pero ese no es el caso. Vea lo que pasa:

```{r, warning=TRUE}
x <- c(1,2,3)
y <- c(10, 20, 30, 40, 50, 60, 70)
x+y
```
Recibimos una advertencia, pero no hay error. [FIX:] Para la salida/output/resultado, R ha reciclado los números en `x`. Observe el último dígito de números en [FIX:] la salida/output.


## Ejercicios

Para estos ejercicios usaremos el conjunto de datos USmurders. Asegúrese de cargarlo antes de comenzar.

```{r}
library(dslabs)
data("murders")
```

1\. Utilice el operador `$` para acceder a los datos del tamaño de la población y almacenarlos como el objeto `pop`. Luego use la función `sort` para redefinir `pop` para que esté en orden alfabética. Finalmente, use el [FIX:] operador `[` para report/reportar/informar/señalar el tamaño de población más pequeño.

2\. Ahora, en lugar del tamaño de población más pequeño, encuentre el índice de la entrada con el tamaño de población más pequeño. Sugerencia: use `order` en lugar de `sort`.

3\. Podemos realizar la misma operación que en el ejercicio anterior usando la función `which.min`. Escribe una línea de código que haga esto.

4\. Ahora sabemos cuán pequeño es el estado más pequeño y qué fila lo representa. ¿Qué estado es?  Define una variable `states` para ser los nombres de estado del _data frame_ `murders`. [FIX:] Report/Informe/indique/señale el nombre del estado con la población más pequeña.

5\. Puede crear un _data frame_ utilizando la función `data.frame`. Aquí un ejemplo:


```{r}
temp <- c(35, 88, 42, 84, 81, 30)
city <- c("Beijing", "Lagos", "Paris", "Rio de Janeiro",
"San Juan", "Toronto")
city_temps <- data.frame(name = city, temperature = temp)
```

Utilice la función `rank` para determinar el rango de población de cada estado desde el menos poblado hasta el más poblado. Guarde estos rangos en un objeto llamado `ranks`, luego crea un _data frame_ con el nombre del estado y su rango. Nombre el  _data frame_ `my_df`.

6\. Repita el ejercicio anterior, pero esta vez ponga `my_df` en orden para que los estados estén en orden de menos poblado a más poblado. Sugerencia: crea un objeto `ind` que almacene los índices necesarios para poner en orden los valores de la población. Luego use [FIX:] el operador de corchete `[` para reordenar cada columna en el _data frame_.

7\. El vector `na_example` representa una serie de conteos. Puede examinar rápidamente el objeto usando:

```{r}
data("na_example")
str(na_example)
```

Sin embargo, cuando calculamos el promedio con la función `mean`, obtenemos un `NA`:

```{r}
mean(na_example)
```

La función `is.na` devuelve un vector lógico que nos dice qué entradas son `NA`. Asigne este vector lógico a un objeto llamado `ind` y determine cuántos `NA`s tiene `na_example`.


8\. Ahora calcule nuevamente el promedio, pero solo para las entradas que no son `NA`. Sugerencia: recuerde el operador `!`.



## Aritmética de vectores

California tuvo la mayor cantidad de asesinatos, pero ¿esto significa que es el estado más peligroso? ¿Qué pasa si solo tiene muchas más personas que cualquier otro estado? Podemos confirmar rápidamente que California tiene la mayor población:

```{r}
library(dslabs)
data("murders")
murders$state[which.max(murders$population)]
```

con más de `r floor(max(murders$population)/10^6)` millones de habitantes. Por lo tanto, es injusto comparar los totales si estamos interesados en saber cuán seguro es el estado. Lo que realmente deberíamos calcular son los asesinatos per cápita. Los informes que describimos en [FIX:] la sección motivadora utilizaron asesinatos por cada 100,000 como la unidad. Para calcular esta cantidad, usamos las poderosas capacidades aritméticas de vectores de R.

### _Rescaling_ un vector

En R, las operaciones aritméticas en vectores ocurren _element-wise_. Como ejemplo, supongamos que tenemos la altura en pulgadas ( _inches_ en inglés):

```{r}
inches <- c(69, 62, 66, 70, 70, 73, 67, 73, 67, 70)
```
y queremos convertirla a centímetros. Noten lo que sucede cuando multiplicamos `inches` por 2.54:

```{r}
inches * 2.54
```

Arriba, multiplicamos cada elemento por 2.54. Del mismo modo, si para cada entrada queremos calcular cuántas pulgadas más alto o más corto que 69 pulgadas, la altura promedio para hombres, podemos restarlo de cada entrada de esta manera:

```{r}
inches - 69
```


### Dos vectores

Si tenemos dos vectores de la misma longitud y los sumamos en R, se agregarán entrada por entrada de la siguiente manera:

$$
\begin{pmatrix}
a\\
b\\
c\\
d
\end{pmatrix}
+
\begin{pmatrix}
e\\
f\\
g\\
h
\end{pmatrix}
=
\begin{pmatrix}
a +e\\
b + f\\
c + g\\
d + h
\end{pmatrix}
$$

Lo mismo aplica para otras operaciones matemáticas, como `-`, `*` y `/`.

Esto implica que para calcular las tasas de asesinatos ( _murder rates_ en inglés) simplemente podemos escribir:

```{r}
murder_rate <- murders$total/ murders$population * 100000
```

Tan pronto hacemos esto, notamos que California ya no está cerca de la parte superior de la lista. De hecho, podemos usar lo que hemos aprendido para ordenar a los estados por tasa de asesinatos:

```{r}
murders$abb[order(murder_rate)]
```


## Ejercicios

1\. Anteriormente creamos este _data frame_:

```{r}
temp <- c(35, 88, 42, 84, 81, 30)
city <- c("Beijing", "Lagos", "Paris", "Rio de Janeiro",
"San Juan", "Toronto")
city_temps <- data.frame(name = city, temperature = temp)
```

Vuelva a crear el  _data frame_ utilizando el código anterior, pero agregue una línea que convierta la temperatura de Fahrenheit a Celsius. La conversión es $C = \frac{5}{9} \times (F - 32)$.

2\. ¿Cuál es la siguiente suma? $1+1/2^2 + 1/3^2 + \dots 1/100^2$? Sugerencia: gracias a Euler, sabemos que debería estar cerca de $\pi^2/6$.

3\. Calcule la tasa de asesinatos por cada 100,000 para cada estado y almacénela en el objeto `murder_rate`. Luego calcule la tasa promedio de asesinatos para EE. UU. con la función `mean`. ¿Cuál es el promedio?

## Indexación

[FIX:] R proporciona una forma poderosa y conveniente de poner vectores en índices. Podemos, por ejemplo, crear un subconjunto de un vector según las propiedades de otro vector. En esta sección, continuamos trabajando con nuestro ejemplo de asesinatos en EE. UU., que podemos cargar así:

```{r}
library(dslabs)
data("murders")
```

### [FIX:] Crear un/Subconjunto con lógicas

Ahora hemos calculado la tasa de asesinatos usando:

```{r}
murder_rate <- murders$total/ murders$population * 100000
```

Imagine que se muda de Italia donde, según un informe de noticias de ABC, la tasa de asesinatos es solo 0.71 por 100,000. Preferiría mudarse a un estado con una tasa de homicidios similar. Otra característica poderosa de R es que podemos usar lógicas para poner en un índice a vectores. Si comparamos un vector con un solo número, se realiza la prueba para cada entrada. Aquí tenemos un ejemplo relacionado con la pregunta anterior:

```{r}
ind <- murder_rate < 0.71
```

Si en cambio queremos saber si un valor es menor o igual, podemos usar:

```{r}
ind <- murder_rate <= 0.71
```

Recuerde que recuperamos un vector lógico con `TRUE` para cada entrada menor o igual a 0.71. Para ver qué estados son estos, podemos aprovechar el hecho de que [FIX:] los vectores se pueden poner en índices [FIX:] con lógicos.

```{r}
murders$state[ind]
```

[FIX:] Para contar cuántos son VERDADEROS, la función `sum` devuelve la suma de las entradas de un vector y los vectores lógicos se _coerced_ a numéricos con `TRUE` codificado como 1 y `FALSE` como 0. Así podemos contar los estados usando:

```{r}
sum(ind)
```


### _Logical Operators_

Supongamos que nos gustan las montañas y queremos mudarnos a un estado seguro en la región occidental del país. Queremos que la tasa de asesinatos sea como máximo 1. En este caso, queremos que dos cosas diferentes sean ciertas. Aquí podemos usar el operador lógico _y_, que en R se representa con `&`. Esta operación da como resultado `TRUE` solo cuando ambas lógicas son `TRUE`. Para ver esto, considere este ejemplo:

```{r}
TRUE & TRUE
TRUE & FALSE
FALSE & FALSE
```

[FIX:] Para nuestro ejemplo, podemos formar dos lógicas:

```{r}
west <- murders$region == "West"
safe <- murder_rate <= 1
```

y podemos usar el `&` para obtener un [FIX:] vector de lógicas que nos dice qué estados satisfacen ambas condiciones:

```{r}
ind <- safe & west
murders$state[ind]
```

### `which`

Supongamos que queremos ver la tasa de asesinatos de California. Para este tipo de operación, es conveniente convertir vectores de lógicos en índices en lugar de mantener largos vectores de lógicos. La función `which` nos dice qué entradas de un vector lógico son [FIX:] VERDADERAS. Entonces podemos escribir:

```{r}
ind <- which(murders$state == "California")
murder_rate[ind]
```


### `match`

Si en lugar de un solo estado queremos averiguar las tasas de homicidio de varios estados, digamos Nueva York, Florida y Texas, podemos usar la función `match`. Esta función nos dice qué índices de un segundo vector coinciden con cada una de las entradas de un primer vector:

```{r}
ind <- match(c("New York", "Florida", "Texas"), murders$state)
ind
```

Ahora podemos ver las tasas de asesinatos:

```{r}
murder_rate[ind]
```

### `%in%`


Si en lugar de un índice queremos una lógica que nos diga si cada elemento de un primer vector está en un segundo, podemos usar la función `%in%`. Imaginemos que no está seguro de si Boston, Dakota y Washington son estados. Puedes averiguar así:

```{r}
c("Boston", "Dakota", "Washington") %in% murders$state
```

Tenga en cuenta que estaremos usando `%in%` frecuentemente a lo largo del libro.

**Avanzado**: hay una conexión entre `match` y `%in%` mediante `which`. Para ver esto, observe que las siguientes dos líneas producen el mismo índice (aunque en diferente orden):

```{r}
match(c("New York", "Florida", "Texas"), murders$state)
which(murders$state%in%c("New York", "Florida", "Texas"))
```

## Ejercicios

Comience cargando la biblioteca y los datos.
```{r}
library(dslabs)
data(murders)
```

1\. Calcule la tasa de asesinatos por cada 100,000 para cada estado y almacénela en un objeto llamado `murder_rate`. Luego use operadores lógicos para crear un vector lógico llamado `low` eso nos dice qué entradas de `murder_rate` son inferiores a 1.

2\. Ahora use los resultados del ejercicio anterior y la función `which` para determinar los índices de `murder_rate` asociados con valores inferiores a 1.

3\. Use los resultados del ejercicio anterior para informar los nombres de los estados con tasas de asesinatos inferiores a 1.

4\. Ahora extienda el código de los ejercicios 2 y 3 para informar los estados del noreste con tasas de homicidios inferiores a 1. Sugerencia: use el vector lógico previamente definido `low` y el operador lógico `&`.

5\. En un ejercicio anterior, calculamos la tasa de homicidios para cada estado y el promedio de estos números. ¿Cuántos estados están por debajo del promedio?

6\. Use la función de coincidencia para identificar los estados con abreviaturas AK, MI e IA. Sugerencia: comience definiendo un índice de las entradas de `murders$abb` que coinciden con las tres abreviaturas, luego use el operador `[` para extraer los estados.

7\. Utilice el operador `%in%` para crear un vector lógico que responda a la pregunta: ¿cuáles de las siguientes son abreviaturas reales: MA, ME, MI, MO, MU?

8\. Extienda el código que usó en el ejercicio 7 para averiguar la única entrada que **no** es una abreviatura real. Sugerencia: use el operador `!`, que gira `FALSE` dentro `TRUE` y viceversa, entonces `which` para obtener un índice.

## [FIX:] Gráficas básicas

En el capitulo \@ref(ggplot2) describimos un paquete [FIX:] complementario que proporciona un enfoque poderoso para producir gráficas ( _plots_ en inglés) en R. Luego tenemos una parte completa sobre la visualización de datos en la que proporcionamos muchos ejemplos. Aquí describimos brevemente algunas de las funciones disponibles en una instalación básica de R.

### `plot`

La función `plot` se puede utilizar para hacer diagramas de dispersión. Aquí hay un gráfico de total de asesinatos versus población.

```{r eval=FALSE}
x <- murders$population/ 10^6
y <- murders$total
plot(x, y)
```


```{r first-plot, out.width="60%", echo=FALSE}
rafalib::mypar()
x <- murders$population/ 10^6
y <- murders$total
plot(x, y)
```

Para crear un gráfico rápido que evita el acceso a las variables dos veces, podemos usar la función `with`:

```{r, eval=FALSE}
with(murders, plot(population, total))
```

La función `with` nos permite usar los nombres en la columna `murders` en la función `plot`. También funciona con cualquier  _data frame_ y cualquier función.

### `hist`

Describiremos los histogramas en relación con las distribuciones en la parte de visualización de datos del texto. Aquí simplemente notaremos que los histogramas son un poderoso resumen gráfico de una lista de números que le brinda una visión general de los tipos de valores que tiene. Podemos hacer un histograma de nuestras tasas de asesinatos simplemente escribiendo:

```{r eval=FALSE}
x <- with(murders, total/ population * 100000)
hist(x)
```

```{r r-base-hist, out.width="60%",echo=FALSE}
rafalib::mypar()
x <- with(murders, total/ population * 100000)
hist(x)
```

Podemos ver que hay una amplia gama de valores con la mayoría de ellos entre 2 y 3 y un caso muy extremo con una tasa de asesinatos de más de 15:

```{r}
murders$state[which.max(x)]
```

### `boxplot`

Los diagramas de caja ( _boxplots_ en inglés) también se describirán en la parte de visualización de datos del libro. Proporcionan un resumen más conciso que los histogramas, pero son más fáciles de apilar con otros diagramas de caja. Por ejemplo, aquí podemos usarlos para comparar las diferentes regiones:

```{r eval=FALSE}
murders$rate <- with(murders, total/ population * 100000)
boxplot(rate~region, data = murders)
```

```{r r-base-boxplot, out.width="60%", echo=FALSE}
rafalib::mypar()
murders$rate <- with(murders, total/ population * 100000)
boxplot(rate~region, data = murders)
```

Podemos ver que el Sur tiene tasas de asesinatos más altas que las otras tres regiones.

### `image`

La función _image_ muestra los valores en una matriz usando color. Aquí hay un ejemplo rápido:

```{r eval=FALSE}
x <- matrix(1:120, 12, 10)
image(x)
```

```{r image-first-example, fig.height=4, fig.width=4, echo=FALSE, out.width="50%"}
rafalib::mypar()
x <- matrix(1:120, 12, 10)
image(x)
```


## Ejercicios

1\. Hicimos una gráfica de asesinatos totales versus población y notamos una fuerte relación. No es sorprendente que los estados con poblaciones más grandes hayan tenido más asesinatos.

```{r, eval = FALSE}
library(dslabs)
data(murders)
population_in_millions <- murders$population/10^6
total_gun_murders <- murders$total
plot(population_in_millions, total_gun_murders)
```

Recuerde que muchos estados tienen poblaciones inferiores a 5 millones y están agrupados. Podemos obtener más información al hacer este diagrama en la escala logarítmica. Transforme las variables usando el `log10` transformación y luego trazarlos.


2\. Crea un histograma de las poblaciones estatales.


3\. Genere diagramas de caja de las poblaciones estatales por región.




